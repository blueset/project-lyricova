# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type Album {
  SongInAlbum: SongInAlbum
  coverUrl: String
  creationDate: Timestamp!
  deletionDate: Timestamp!
  id: Int!
  incomplete: Boolean!
  name: String!
  sortOrder: String!
  updatedOn: Timestamp!
}

"""Describes the animation sequence for a word."""
type AnimatedWord {
  """
  True if the word shows a conversion-type of animation. False if it is just typing.
  """
  convert: Boolean!

  """Actual sequence to show, one frame at a time."""
  sequence: [String!]!
}

type Artist {
  ArtistOfAlbum: ArtistOfAlbum
  ArtistOfSong: ArtistOfSong
  creationDate: Timestamp!
  id: Int!
  incomplete: Boolean!
  mainPictureUrl: String
  name: String!
  sortOrder: String!
  type: String!
  updatedOn: Timestamp!
  vocaDbJson: JSONObject!
}

type ArtistOfAlbum {
  artistOfAlbumId: Int!
  categories: String!
  effectiveRoles: [String!]!
  roles: [String!]!
}

type ArtistOfSong {
  artistOfSongId: Int!
  artistRoles: [String!]!
  categories: [String!]!
  creationDate: Timestamp!
  customName: String
  isSupport: Boolean!
  updatedOn: Timestamp!
  vocaDbId: Int
}

input ArtistOfSongInput {
  artistId: Int!
  artistRoles: [String!]!
  categories: [String!]!
  customName: String
  isSupport: Boolean! = false
}

type DashboardStats {
  aliveStartedOn: Timestamp!
  entriesCount: Int!
  pulsesCount: Int!
  revampStartedOn: Timestamp!
  tagsCount: Int!
}

"""A Lyricova entry."""
type Entry {
  author: User!
  authorId: Float!
  comment: String
  creationDate: Timestamp!
  id: Float!
  producersName: String!
  pulses: [Pulse!]
  recentActionDate: Timestamp!
  songs: [Song!]
  tags: [Tag!]
  title: String!
  updatedOn: Timestamp!
  verses: [Verse!]
  vocalistsName: String!
}

input EntryInput {
  comment: String
  creationDate: Timestamp
  producersName: String
  pulses: [PulseInput!]
  songIds: [Float!]
  tagSlugs: [String!]
  title: String!
  verses: [VerseInput!]!
  vocalistsName: String
}

type FileInPlaylist {
  creationDate: Timestamp!
  id: Int!
  sortOrder: Int!
  updatedOn: Timestamp!
}

"""Foo is not foolish."""
type Foo {
  """Not a value to drink."""
  bar: Int!

  """Name of the foo."""
  name: String!
}

"""Furigana/romaji to words in a lyrics line."""
input FuriganaLabel {
  """Furigana/romaji content"""
  content: String!

  """Starting character per Extended Grapheme Cluster (including)"""
  leftIndex: Int!

  """Ending character per Extended Grapheme Cluster (excluding)"""
  rightIndex: Int!
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

"""A music file in the jukebox."""
type MusicFile {
  FileInPlaylist: FileInPlaylist

  """ID of corresponding album in database."""
  albumId: Int

  """Album of the track stored in file."""
  albumName: String

  """Sort order key of album of the track stored in file."""
  albumSortOrder: String

  """Artist of the track stored in file."""
  artistName: String

  """Sort order key of artist of the track stored in file."""
  artistSortOrder: String
  creationDate: Timestamp!

  """Duration of the song in seconds."""
  duration: Float!

  """Size of file in bytes."""
  fileSize: Int!

  """If the file has an embedded cover art."""
  hasCover: Boolean!

  """If the file is accompanied with a lyrics file."""
  hasLyrics: Boolean!

  """MD5 of the file."""
  hash: String!

  """File ID in database."""
  id: Int!

  """Date when the file was last played."""
  lastPlayed: Timestamp

  """If this entry needs review."""
  needReview: Boolean!

  """Local path to the song."""
  path: String!

  """Number of times the file has been played."""
  playCount: Int!

  """ID of corresponding song in database."""
  songId: Int

  """Name of the track stored in file."""
  trackName: String

  """Sort order key of name of the track stored in file."""
  trackSortOrder: String
  updatedOn: Timestamp!
}

type Mutation {
  bumpEntry(id: Int!): Boolean!
  deleteCredential(id: Int!): Boolean!
  deleteEntry(id: Int!): Boolean!
  deleteTag(slug: String!): Boolean!

  """Insert or update an album from VocaDB."""
  enrolAlbumFromVocaDB(
    """Album ID in VocaDB"""
    albumId: Int!
  ): Album!

  """Insert or update an artist from VocaDB."""
  enrolArtistFromVocaDB(
    """Artist ID in VocaDB"""
    artistId: Int!
  ): Artist!

  """Insert or update a song from VocaDB."""
  enrolSongFromVocaDB(
    """Song ID in VocaDB"""
    songId: Int!
  ): Song!
  newEntry(data: EntryInput!): Entry!
  newSong(data: SongInput!): Song!
  newTag(data: NewTagInput!): Tag!
  pulseEntry(id: Float!): Entry!
  unpulseEntry(id: Float!, pulseId: Float!): Entry!
  updateEntry(data: EntryInput!, id: Int!): Entry!
  updateSong(data: SongInput!, id: Int!): Song!
  updateTag(data: UpdateTagInput!, slug: String!): Tag!
}

input NewTagInput {
  color: String!
  name: String!
  slug: String!
}

"""A playlist of music files."""
type Playlist {
  """Name of the playlist."""
  name: String!

  """Slug of the playlist."""
  slug: ID!
}

type Pulse {
  creationDate: Timestamp!
  id: Int!
}

input PulseInput {
  creationDate: Timestamp!
  id: Int
}

type Query {
  currentCredentials: [UserPublicKeyCredential!]!
  currentUser: User
  dashboardStats: DashboardStats!
  entries: [Entry!]!
  entry(id: Int!): Entry
  foo: Foo!
  foos: [Foo!]!
  hash(plaintext: String!): String!
  searchSongs(keywords: String!): [Song!]!
  song(id: Int!): Song
  songs: [Song!]!
  startALengthyTask(sessionId: String!): [String!]!
  tag(slug: String!): Tag
  tags: [Tag!]!
  transliterate(furigana: [[FuriganaLabel!]!]! = [], text: String!): TransliterationResult!
}

type Song {
  SongInAlbum: SongInAlbum
  albums: [Album!]
  artists: [Artist!]
  coverUrl: String
  creationDate: Timestamp!
  derivedSongs: [Song!]
  files: [MusicFile!]
  id: Int!
  incomplete: Boolean!
  name: String!
  original: Song
  originalId: Int
  sortOrder: String!
  updatedOn: Timestamp!
  videos: [VideoFile!]
  vocaDbJson: JSONObject!
}

type SongInAlbum {
  creationDate: Timestamp!
  diskNumber: Int
  name: String
  trackNumber: Int
  updatedOn: Timestamp!
  vocaDbId: Int
}

input SongInAlbumOnSongInput {
  albumId: Int!
  diskNumber: Int
  name: String
  trackNumber: Int
}

input SongInput {
  artistsOfSong: [ArtistOfSongInput!]!
  coverUrl: String!
  name: String!
  originalId: Int
  songInAlbums: [SongInAlbumOnSongInput!]!
  sortOrder: String!
}

type Subscription {
  aLengthyTask(sessionId: String!): String
}

type Tag {
  color: String!
  entries: [Entry!]!
  name: String!
  slug: ID!
}

type TagOfEntry {
  id: ID!
}

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

"""Result of a transliteration request."""
type TransliterationResult {
  karaoke(
    """
    Language of the query, choose from "ja", "zh", and "en". Leave blank for auto detection.
    """
    language: String
  ): [[[String!]!]!]!
  plain(
    """
    Language of the query, choose from "ja", "zh", and "en". Leave blank for auto detection.
    """
    language: String
  ): String!
  plainSegmented(
    """
    Language of the query, choose from "ja", "zh", and "en". Leave blank for auto detection.
    """
    language: String
  ): [[[String!]!]!]!

  """Original text."""
  text: String!
  typing(
    """
    Language of the query, choose from "ja", "zh", and "en". Leave blank for auto detection.
    """
    language: String
  ): [[[String!]!]!]!
  typingSequence(
    """
    Language of the query, choose from "ja", "zh", and "en". Leave blank for auto detection.
    """
    language: String
  ): [[AnimatedWord!]!]!
}

input UpdateTagInput {
  color: String
  name: String
  slug: String
}

type User {
  creationDate: Timestamp!
  displayName: String!
  email: String!
  emailMD5: String!
  id: Int!
  role: String!
  username: String!
}

type UserPublicKeyCredential {
  creationDate: Timestamp!
  id: Float!
  remarks: String
  updatedOn: Timestamp!
  userId: Float!
}

type Verse {
  html: String
  id: Float!
  isMain: Boolean!
  isOriginal: Boolean!
  language: String!
  stylizedText: String
  text: String!
  translator: String
  typingSequence: [[[String!]!]!]!
}

input VerseInput {
  html: String
  id: Float
  isMain: Boolean! = false
  isOriginal: Boolean! = false
  language: String!
  stylizedText: String
  text: String!
  translator: String
  typingSequence: [[[String!]!]!]! = []
}

type VideoFile {
  id: Int!
}