# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type Album {
  SongInAlbum: SongInAlbum
  artists: [Artist!]
  coverUrl: String
  creationDate: Timestamp!
  deletionDate: Timestamp!
  files: [MusicFile!]
  id: Int!
  incomplete: Boolean!
  name: String!
  songs: [Song!]
  sortOrder: String!
  updatedOn: Timestamp!
}

input AlbumInput {
  artistsOfAlbum: [ArtistOfAlbumInput!]!
  coverUrl: String
  name: String!
  songsInAlbum: [SongInAlbumOnAlbumInput!]!
  sortOrder: String!
}

"""Describes the animation sequence for a word."""
type AnimatedWord {
  """
  True if the word shows a conversion-type of animation. False if it is just typing.
  """
  convert: Boolean!

  """Actual sequence to show, one frame at a time."""
  sequence: [String!]!
}

type Artist {
  ArtistOfAlbum: ArtistOfAlbum
  ArtistOfSong: ArtistOfSong
  albums: [Album!]
  baseVoiceBank: Artist
  creationDate: Timestamp!
  derivedVoiceBanks: [Artist!]
  id: Int!
  incomplete: Boolean!
  mainPictureUrl: String
  name: String!
  songs: [Song!]
  sortOrder: String!
  type: String!
  updatedOn: Timestamp!
  vocaDbJson: JSONObject!
}

input ArtistInput {
  mainPictureUrl: String
  name: String!
  sortOrder: String!
  type: String!
}

type ArtistOfAlbum {
  artistOfAlbumId: Int!
  categories: String!
  effectiveRoles: [String!]!
  roles: [String!]!
}

input ArtistOfAlbumInput {
  artistId: Int!
  categories: String!
  effectiveRoles: [String!]!
  roles: [String!]!
}

type ArtistOfSong {
  artistOfSongId: Int!
  artistRoles: [String!]!
  categories: [String!]!
  creationDate: Timestamp!
  customName: String
  isSupport: Boolean!
  updatedOn: Timestamp!
  vocaDbId: Int
}

input ArtistOfSongInput {
  artistId: Int!
  artistRoles: [String!]!
  categories: [String!]!
  customName: String
  isSupport: Boolean! = false
}

type DashboardStats {
  albumCount: Int!
  aliveStartedOn: Timestamp!
  artistCount: Int!
  filesHasCoverCount: Int!
  filesHasLyricsCount: Int!
  musicFilesCount: Int!
  revampStartedOn: Timestamp!
  reviewedFilesCount: Int!
  songCount: Int!
}

"""A Lyricova entry."""
type Entry {
  author: User!
  authorId: Float!
  comment: String
  creationDate: Timestamp!
  id: Float!
  producersName: String!
  recentActionDate: Timestamp!
  title: String!
  updatedOn: Timestamp!
  vocalistsName: String!
}

type FileInPlaylist {
  creationDate: Timestamp!
  id: Int!
  sortOrder: Int!
  updatedOn: Timestamp!
}

"""Foo is not foolish."""
type Foo {
  """Not a value to drink."""
  bar: Int!

  """Name of the foo."""
  name: String!
}

"""Furigana/romaji to words in a lyrics line."""
input FuriganaLabel {
  """Furigana/romaji content"""
  content: String!

  """Starting character per Extended Grapheme Cluster (including)"""
  leftIndex: Int!

  """Ending character per Extended Grapheme Cluster (excluding)"""
  rightIndex: Int!
}

"""A lyrics entry from 初音ミク@wiki."""
type HmikuAtWikiEntry {
  """Furigana of the entry name."""
  furigana: String!

  """Entry ID."""
  id: String!

  """Lyrics content."""
  lyrics: String!

  """Entry name."""
  name: String!
}

"""A search result from 初音ミク@wiki."""
type HmikuAtWikiSearchResultEntry {
  """A short summary of contents in the entry."""
  desc: String!

  """Entry ID."""
  id: String!

  """Entry name."""
  name: String!
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

"""Attachments to a lyrics line."""
type LyricsKitAttachment {
  furigana: [LyricsKitRangeAttachment!]
  romaji: [LyricsKitRangeAttachment!]
  timeTag: LyricsKitWordTimeAttachment
  translation: String
}

"""Parsed lyrics."""
type LyricsKitLyrics {
  """Duration of the lyrics in seconds."""
  length: Float
  lines: [LyricsKitLyricsLine!]!
  quality: Float
}

"""A lyrics entry from lyrics-kit search engine."""
type LyricsKitLyricsEntry {
  """If the query is matched in this entry."""
  isMatched: Boolean!
  lyrics: String!
  metadata: JSONObject!

  """Quality of the matching."""
  quality: Float
  tags: JSONObject!
}

"""A line of parsed lyrics."""
type LyricsKitLyricsLine {
  attachments: LyricsKitAttachment!
  content: String!

  """Offset of the line in seconds"""
  position: Float!
}

"""Furigana/romaji to words in a lyrics line."""
type LyricsKitRangeAttachment {
  """Furigana/romaji content"""
  content: String!

  """Starting character per Extended Grapheme Cluster (including)"""
  leftIndex: Int!

  """Ending character per Extended Grapheme Cluster (excluding)"""
  rightIndex: Int!
}

input LyricsKitSearchOptions {
  """Duration of the song (if known)."""
  duration: Float! = 0

  """Whether to output LRCX syntax."""
  useLRCX: Boolean! = false
}

"""Time tag per word to a lyrics line."""
type LyricsKitWordTimeAttachment {
  """Duration of line in seconds."""
  duration: Float

  """Tags in the line."""
  tags: [LyricsKitWordTimeTag!]
}

"""Time tag per word to a lyrics line."""
type LyricsKitWordTimeTag {
  """Starting character per Extended Grapheme Cluster of this tag"""
  index: Int!

  """Time when the time tag happens, in seconds."""
  timeTag: Float!
}

type MusicDlSearchResult {
  album: String
  artists: String
  coverURL: String
  duration: Float
  lyricsURL: String
  pickle: String!
  size: Int
  songURL: String
  source: String!
  title: String
}

"""A music file in the jukebox."""
type MusicFile {
  FileInPlaylist: FileInPlaylist
  album: Album

  """ID of corresponding album in database."""
  albumId: Int

  """Album of the track stored in file."""
  albumName: String

  """Sort order key of album of the track stored in file."""
  albumSortOrder: String

  """Artist of the track stored in file."""
  artistName: String

  """Sort order key of artist of the track stored in file."""
  artistSortOrder: String
  creationDate: Timestamp!

  """Duration of the song in seconds."""
  duration: Float!

  """Size of file in bytes."""
  fileSize: Int!

  """If the file has an embedded cover art."""
  hasCover: Boolean!

  """If the file is accompanied with a lyrics file."""
  hasLyrics: Boolean!

  """MD5 of the file."""
  hash: String!

  """File ID in database."""
  id: Int!

  """Date when the file was last played."""
  lastPlayed: Timestamp
  lyrics: LyricsKitLyrics
  lyricsText(ext: String! = "lrc"): String

  """If this entry needs review."""
  needReview: Boolean!

  """Local path to the song."""
  path: String!

  """Number of times the file has been played."""
  playCount: Int!
  playlists: [Playlist!]!
  song: Song

  """ID of corresponding song in database."""
  songId: Int

  """Name of the track stored in file."""
  trackName: String

  """Sort order key of name of the track stored in file."""
  trackSortOrder: String
  updatedOn: Timestamp!
}

"""Write metadata to music file."""
input MusicFileInput {
  """ID of corresponding album in database."""
  albumId: Int

  """Album of the track stored in file."""
  albumName: String

  """Sort order key of album of the track stored in file."""
  albumSortOrder: String

  """Artist of the track stored in file."""
  artistName: String

  """Sort order key of artist of the track stored in file."""
  artistSortOrder: String

  """ID of corresponding song in database."""
  songId: Int

  """Name of the track stored in file."""
  trackName: String

  """Sort order key of name of the track stored in file."""
  trackSortOrder: String
}

type MusicFilesPagination {
  edges: [MusicFilesPaginationEdge!]!
  pageInfo: PaginationInfo!
  totalCount: Int!
}

type MusicFilesPaginationEdge {
  cursor: String!
  node: MusicFile!
}

"""Music files query options"""
input MusicFilesQueryOptions {
  """Filter by review status of files"""
  needReview: Boolean
}

type MusicFilesScanOutcome {
  added: Int!
  deleted: Int!
  total: Int!
  unchanged: Int!
  updated: Int!
}

type Mutation {
  addFileToPlaylist(fileId: Int!, slug: String!): Playlist!

  """Bump play count of a file"""
  bumpPlayCount(
    """Music file ID"""
    fileId: Int!
  ): Int!

  """Insert or update an album from VocaDB."""
  enrolAlbumFromVocaDB(
    """Album ID in VocaDB"""
    albumId: Int!
  ): Album!

  """Insert or update an artist from VocaDB."""
  enrolArtistFromVocaDB(
    """Artist ID in VocaDB"""
    artistId: Int!
  ): Artist!

  """Insert or update a song from VocaDB."""
  enrolSongFromVocaDB(
    """Song ID in VocaDB"""
    songId: Int!
  ): Song!
  newAlbum(data: AlbumInput!): Album!
  newArtist(data: ArtistInput!): Artist!
  newPlaylist(data: NewPlaylistInput!): Playlist!
  newSong(data: SongInput!): Song!
  removeFileFromPlaylist(fileId: Int!, slug: String!): Playlist!

  """Remove lyrics of a file"""
  removeLyrics(
    """Music file ID"""
    fileId: Int!
  ): Boolean!
  removePlaylist(slug: String!): Boolean!
  scan(sessionId: String): MusicFilesScanOutcome!

  """
  Scan a single file based on its path. This may create, update or delete an entry.
  """
  scanByPath(
    """Path to scan relative to MUSIC_DATA_PATH."""
    path: String!
  ): MusicFile

  """Set which playlist a file belong to, this replaces existing values."""
  setPlaylistsOfFile(
    """Music file ID"""
    fileId: Int!

    """Playlists to set"""
    playlistSlugs: [String!]!
  ): MusicFile!

  """Write lyrics to music file as a tag"""
  toggleMusicFileReviewStatus(
    """Music file ID"""
    fileId: Int!

    """If the file still needs review"""
    needReview: Boolean!
  ): MusicFile!
  updateAlbum(data: AlbumInput!, id: Int!): Album!
  updateArtist(data: ArtistInput!, id: Int!): Artist!
  updateMusicFileStats(
    """Music file ID"""
    fileId: Int!

    """Last played"""
    lastPlayed: Timestamp

    """Play count"""
    playCount: Int!
  ): MusicFile!
  updatePlaylist(data: UpdatePlaylistInput!, slug: String!): Playlist!
  updatePlaylistFiles(fileIds: [Int!]!, slug: String!): Playlist!
  updatePlaylistSortOrder(fileIds: [Int!]!, slug: String!): Playlist!
  updateSong(data: SongInput!, id: Int!): Song!

  """Write lyrics to a separate file"""
  writeLyrics(
    """Lyrics file extension"""
    ext: String! = "lrc"

    """Music file ID"""
    fileId: Int!

    """Lyrics file content"""
    lyrics: String!
  ): Boolean!

  """Write lyrics to music file as a tag"""
  writeLyricsToMusicFile(
    """Music file ID"""
    fileId: Int!

    """Lyrics content"""
    lyrics: String!
  ): Boolean!
  writeTagsToMusicFile(data: MusicFileInput!, id: Int!): MusicFile!

  """Download audio via yt-dlp."""
  youtubeDlDownloadAudio(options: YouTubeDlDownloadOptions!, sessionId: String = null, url: String!): String
}

input NewPlaylistInput {
  name: String!
  slug: String!
}

type PaginationInfo {
  endCursor: String
  hasNextPage: Boolean!
}

"""A playlist of music files."""
type Playlist {
  files: [MusicFile!]!
  filesCount: Int!

  """Name of the playlist."""
  name: String!

  """Slug of the playlist."""
  slug: ID!
}

type Pulse {
  creationDate: Timestamp!
  id: Int!
}

type Query {
  album(id: Int!): Album
  albums: [Album!]!
  albumsHasFiles: [Album!]!
  artist(id: Int!): Artist
  artists: [Artist!]!
  artistsHasFiles(types: [String!]! = ["Unknown", "Circle", "Label", "Producer", "Animator", "Illustrator", "Lyricist", "Vocaloid", "UTAU", "CeVIO", "OtherVoiceSynthesizer", "OtherVocalist", "OtherGroup", "OtherIndividual", "Utaite", "Band", "Vocalist", "Character"]): [Artist!]!
  artistsWithFilesNeedEnrol: [Int!]!
  currentUser: User
  dashboardStats: DashboardStats!
  foo: Foo!
  foos: [Foo!]!
  hash(plaintext: String!): String!
  hmikuLyrics(id: String!): HmikuAtWikiEntry
  hmikuLyricsSearch(keyword: String!): [HmikuAtWikiSearchResultEntry!]!
  lyricsKitSearch(
    artists: String!
    options: LyricsKitSearchOptions!

    """
    Session ID for subscribing to incremental search results with `lyricsKitSearchIncremental`.
    """
    sessionId: String
    title: String!
  ): [LyricsKitLyricsEntry!]!
  musicFile(id: Int!): MusicFile
  musicFiles(after: String, first: Int! = 25, options: MusicFilesQueryOptions): MusicFilesPagination!

  """Get music files added in 30 days"""
  newMusicFiles: [MusicFile!]!
  playlist(slug: String!): Playlist
  playlists: [Playlist!]!

  """Get music files played the most"""
  popularMusicFiles(
    """Limit of results"""
    limit: Int!
  ): [MusicFile!]!
  randomTexture: Texture!

  """Get music files played in 30 days"""
  recentMusicFiles: [MusicFile!]!
  searchAlbums(keywords: String!): [Album!]!
  searchArtists(keywords: String!): [Artist!]!
  searchMusicFiles(keywords: String!): [MusicFile!]!
  searchSongs(keywords: String!): [Song!]!
  song(id: Int!): Song
  songs: [Song!]!
  startALengthyTask(sessionId: String!): [String!]!
  transliterate(furigana: [[FuriganaLabel!]!]! = [], text: String!): TransliterationResult!
  vocaDBLyrics(id: Int!): [VocaDBLyricsEntry!]!
  youtubeDlGetInfo(url: String!): JSONObject!
}

type Song {
  SongInAlbum: SongInAlbum
  albums: [Album!]
  artists: [Artist!]
  coverUrl: String
  creationDate: Timestamp!
  derivedSongs: [Song!]
  files: [MusicFile!]
  id: Int!
  incomplete: Boolean!
  name: String!
  original: Song
  originalId: Int
  sortOrder: String!
  updatedOn: Timestamp!
  videos: [VideoFile!]
  vocaDbJson: JSONObject!
}

type SongInAlbum {
  creationDate: Timestamp!
  diskNumber: Int
  name: String
  trackNumber: Int
  updatedOn: Timestamp!
  vocaDbId: Int
}

input SongInAlbumOnAlbumInput {
  diskNumber: Int
  name: String
  songId: Int!
  trackNumber: Int
}

input SongInAlbumOnSongInput {
  albumId: Int!
  diskNumber: Int
  name: String
  trackNumber: Int
}

input SongInput {
  artistsOfSong: [ArtistOfSongInput!]!
  coverUrl: String!
  name: String!
  originalId: Int
  songInAlbums: [SongInAlbumOnSongInput!]!
  sortOrder: String!
}

type Subscription {
  aLengthyTask(sessionId: String!): String

  """
  Incremental retrieve results of a `lyricsKitSearch`. Session ID is required when performing search.
  """
  lyricsKitSearchIncremental(sessionId: String!): LyricsKitLyricsEntry

  """Progress of a `scan`. Session ID is required when performing search."""
  scanProgress(sessionId: String!): MusicFilesScanOutcome

  """
  Progress of a `youTubeDlDownloadVideo` mutation. Session ID is required when performing mutation.
  """
  youTubeDlDownloadProgress(sessionId: String!): YouTubeDlProgress
}

type Tag {
  color: String!
  name: String!
  slug: ID!
}

type TagOfEntry {
  id: ID!
}

type Texture {
  author: String!
  authorUrl: String
  name: String!
  url: String!
}

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

"""Result of a transliteration request."""
type TransliterationResult {
  karaoke(
    """
    Language of the query, choose from "ja", "zh", and "en". Leave blank for auto detection.
    """
    language: String
  ): [[[String!]!]!]!
  plain(
    """
    Language of the query, choose from "ja", "zh", and "en". Leave blank for auto detection.
    """
    language: String
  ): String!
  plainSegmented(
    """
    Language of the query, choose from "ja", "zh", and "en". Leave blank for auto detection.
    """
    language: String
  ): [[[String!]!]!]!

  """Original text."""
  text: String!
  typing(
    """
    Language of the query, choose from "ja", "zh", and "en". Leave blank for auto detection.
    """
    language: String
  ): [[[String!]!]!]!
  typingSequence(
    """
    Language of the query, choose from "ja", "zh", and "en". Leave blank for auto detection.
    """
    language: String
  ): [[AnimatedWord!]!]!
}

input UpdatePlaylistInput {
  name: String
  slug: String
}

type User {
  creationDate: Timestamp!
  displayName: String!
  email: String!
  emailMD5: String!
  id: Int!
  role: String!
  username: String!
}

type Verse {
  html: String
  id: Float!
  isMain: Boolean!
  isOriginal: Boolean!
  language: String!
  stylizedText: String
  text: String!
  translator: String
  typingSequence: [[[String!]!]!]!
}

type VideoFile {
  id: Int!
}

"""A lyrics entry from VocaDB."""
type VocaDBLyricsEntry {
  """Language/culture code."""
  cultureCode: String

  """Lyrics entry ID."""
  id: Int!

  """Source of lyrics."""
  source: String

  """Type of translation."""
  translationType: String

  """URL of the source."""
  url: String

  """Lyrics content."""
  value: String
}

type YouTubeDlDownloadMessage {
  message: String!
}

input YouTubeDlDownloadOptions {
  """Name of file to save as."""
  filename: String

  """Whether to overwrite if a file already exists."""
  overwrite: Boolean! = false
}

type YouTubeDlInfo {
  filename: String!
  metadata: JSONObject!

  """Size of file in bytes, precision to every 10486 bytes."""
  size: Int!
}

union YouTubeDlProgress = YouTubeDlProgressDone | YouTubeDlProgressError | YouTubeDlProgressMessage | YouTubeDlProgressValue

"""youtube-dl download progress when download is finished."""
type YouTubeDlProgressDone {
  """Type of update, "done"."""
  type: String!
}

"""youtube-dl download progress when download failed."""
type YouTubeDlProgressError {
  message: String!

  """Type of update, "error"."""
  type: String!
}

type YouTubeDlProgressMessage {
  message: String!

  """Type of update, "message"."""
  type: String!
}

"""youtube-dl download progress object."""
type YouTubeDlProgressValue {
  current: Float!
  eta: String
  speed: String
  total: Float!

  """Type of update, "progress"."""
  type: String!
}